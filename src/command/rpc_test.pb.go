// Code generated by protoc-gen-gogo.
// source: command/rpc_test.proto
// DO NOT EDIT!

/*
	Package command is a generated protocol buffer package.

	It is generated from these files:
		command/rpc_test.proto

	It has these top-level messages:
		AddRequest
		AddReply
*/
package command

import proto "github.com/gogo/protobuf/proto"
import math "math"
import "base/xnet"

// discarding unused import gogoproto "github.com/gogo/protobuf/gogoproto"

import "time"

import io "io"
import fmt "fmt"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

type AddRequest struct {
	A                int32  `protobuf:"varint,1,opt,def=0" json:"A" form:"A"`
	B                int32  `protobuf:"varint,2,opt,def=0" json:"B" form:"B"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *AddRequest) Reset()         { *m = AddRequest{} }
func (m *AddRequest) String() string { return proto.CompactTextString(m) }
func (*AddRequest) ProtoMessage()    {}
func (m *AddRequest) IsNil() bool    { return nil == m || (*AddRequest)(nil) == m }

const Default_AddRequest_A int32 = 0
const Default_AddRequest_B int32 = 0

func (m *AddRequest) GetA() int32 {
	if m != nil {
		return m.A
	}
	return Default_AddRequest_A
}

func (m *AddRequest) GetB() int32 {
	if m != nil {
		return m.B
	}
	return Default_AddRequest_B
}

type AddReply struct {
	X                int32  `protobuf:"varint,1,opt,def=0" json:"X" form:"X"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *AddReply) Reset()         { *m = AddReply{} }
func (m *AddReply) String() string { return proto.CompactTextString(m) }
func (*AddReply) ProtoMessage()    {}
func (m *AddReply) IsNil() bool    { return nil == m || (*AddReply)(nil) == m }

const Default_AddReply_X int32 = 0

func (m *AddReply) GetX() int32 {
	if m != nil {
		return m.X
	}
	return Default_AddReply_X
}

var rpc_test_factory = map[uint32]func() xnet.Message{
	599425190:  func() xnet.Message { return &AddRequest{} },
	1397926977: func() xnet.Message { return &AddReply{} },
}

var rpc_test_hash_names = map[uint32]string{
	599425190:  "AddRequest",
	1397926977: "AddReply",
}

var rpc_test_name_hashs = map[string]uint32{
	"AddRequest": 599425190,
	"AddReply":   1397926977,
}

func init() {
	// rpc_test.proto
	RegisterProtoFactroy(&rpc_test_factory, &rpc_test_hash_names, &rpc_test_name_hashs)
}
func (m *AddRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AddRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.A != Default_AddRequest_A {
		data[i] = 0x8
		i++
		i = encodeVarintRpcTest(data, i, uint64(m.A))
	}
	if m.B != Default_AddRequest_B {
		data[i] = 0x10
		i++
		i = encodeVarintRpcTest(data, i, uint64(m.B))
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AddReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AddReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.X != Default_AddReply_X {
		data[i] = 0x8
		i++
		i = encodeVarintRpcTest(data, i, uint64(m.X))
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeFixed64RpcTest(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32RpcTest(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintRpcTest(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}

type IMathService interface {
	Add(context *xnet.Context, in *AddRequest, out *AddReply) *string
}

// generate MathServiceModule to implementation IServiceModule.
type MathServiceModule struct {
	IMathService
}

func NewMathServiceModule(svc IMathService) *MathServiceModule {
	return &MathServiceModule{IMathService: svc}
}

func (this *MathServiceModule) Name() string {
	return "MathService"
}

func (this *MathServiceModule) Impl() interface{} {
	return this.IMathService
}

func (this *MathServiceModule) ServiceCall(ctx *xnet.Context, rpc_id uint32, in xnet.Message) (reply xnet.Message, err *string) {

	switch rpc_id {
	case uint32(1173007300):
		out := &AddReply{}
		reply, err = out, this.IMathService.Add(ctx, in.(*AddRequest), out)

	default:
		err = proto.String("MethodNotFound")
	}

	return
}

// generate MathServiceImpl
type MathServiceImpl struct {
	*xnet.RpcService
	xnet.IServiceModule
}

// NewMathServiceServer returns a new MathService Server.
func NewMathServiceImpl(rawurl string, impl IMathService) (*MathServiceImpl, error) {
	var service *xnet.RpcService
	var err error
	if service, err = xnet.ListenRpc(rawurl); err != nil {
		return nil, err
	}
	return NewMathServiceImplFrom(service, impl)
}

// NewMathServiceServer use proxy.
func NewMathServiceImplWithProxy(rawurl, proxy_url string) (*MathServiceImpl, error) {

	// dial remote service with proxy_url.
	impl, err := NewMathServiceProxy(proxy_url, time.Second*15)
	// dial remote service to failed.
	if err != nil {
		return nil, err
	}

	// create local service with rawurl.
	var service *MathServiceImpl
	if service, err = NewMathServiceImpl(rawurl, impl); nil != err {
		impl.proxy.Close(err)
		return nil, err
	}

	return service, nil
}

func NewMathServiceImplFrom(service *xnet.RpcService, impl IMathService) (*MathServiceImpl, error) {
	svc_impl := &MathServiceImpl{
		RpcService:     service,
		IServiceModule: NewMathServiceModule(impl),
	}

	service.RegisterService(svc_impl.IServiceModule)

	return svc_impl, nil
}

func (this *MathServiceImpl) Startup() {
	this.Dispatcher().RegisterService(this.IServiceModule)
}

func (this *MathServiceImpl) Shutdown() {
	this.Dispatcher().UnregisterService(this.IServiceModule)
}

// define IMathServiceClient interface
type IMathServiceClient interface {
	xnet.ISession

	Add(*AddRequest) (*AddReply, *string)
	AsyncAdd(*AddRequest, func(*string, *AddReply))
}

// implement IMathServiceClient interface.
type MathServiceClient struct {
	xnet.ISession
}

// New MathServiceClient from ISession.
func NewMathServiceClient(conn xnet.ISession) IMathServiceClient {
	return &MathServiceClient{conn}
}

// DialMathService connects to an MathService at the specified network address.
func DialMathService(rawurl string) (IMathServiceClient, error) {
	return DialMathServiceTimeout(rawurl, time.Second*15)
}

// DialMathService connects to an MathService at the specified network address.
func DialMathServiceTimeout(rawurl string, timeout time.Duration) (IMathServiceClient, error) {
	c, err := xnet.DialRpc(rawurl, timeout)
	if err != nil {
		return nil, err
	}
	return &MathServiceClient{c}, nil
}

func (this *MathServiceClient) Add(in *AddRequest) (*AddReply, *string) {
	xnet.Assert(nil != in, "nil pointer: *AddRequest")
	// MathService.Add = 1173007300
	// reply, err := this.Call( "MathService.Add", in )
	reply, err := this.CallTimeout(1173007300, xnet.RPC_TIMEOUT, in)
	if nil != reply && (*AddReply)(nil) != reply {
		return reply.(*AddReply), err
	}
	return nil, err
}

func (this *MathServiceClient) AsyncAdd(in *AddRequest, handler func(*string, *AddReply)) {
	xnet.Assert(nil != in, "nil pointer: *AddRequest")
	xnet.Assert(nil != handler, "nil handler: func(*string, *AddReply)")
	// MathService.Add = 1173007300
	// this.AsyncCall("MathService.Add", in, func(err *string, reply xnet.Message) {
	this.AsyncCallTimeout(1173007300, xnet.RPC_TIMEOUT, in, func(err *string, reply xnet.Message) {
		var output *AddReply
		if nil != reply && (*AddReply)(nil) != reply {
			output = reply.(*AddReply)
		}
		handler(err, output)
	})
}

// generate MathServiceProxy to implementation IMathService interface.
type MathServiceProxy struct {
	proxy IMathServiceClient
}

func NewMathServiceProxy(rawurl string, timeout time.Duration) (*MathServiceProxy, error) {
	client, err := DialMathServiceTimeout(rawurl, timeout)
	if nil != err {
		return nil, err
	}
	return &MathServiceProxy{proxy: client}, nil
}

// IMathService.Add
func (this *MathServiceProxy) Add(ctx *xnet.Context, in *AddRequest, out *AddReply) *string {
	this.proxy.AsyncAdd(in, func(err *string, resp *AddReply) {
		ctx.Response(err, resp)
	})
	return ctx.Asynchronized()
}

func (m *AddRequest) Size() (n int) {
	var l int
	_ = l
	if m.A != Default_AddRequest_A {
		n += 1 + sovRpcTest(uint64(m.A))
	}
	if m.B != Default_AddRequest_B {
		n += 1 + sovRpcTest(uint64(m.B))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddReply) Size() (n int) {
	var l int
	_ = l
	if m.X != Default_AddReply_X {
		n += 1 + sovRpcTest(uint64(m.X))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovRpcTest(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRpcTest(x uint64) (n int) {
	return sovRpcTest(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AddRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			m.A = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.A |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			m.B = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.B |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipRpcTest(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *AddReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.X |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipRpcTest(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func skipRpcTest(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for {
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRpcTest
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRpcTest(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRpcTest = fmt.Errorf("proto: negative length found during unmarshaling")
)
