// Copyright 2015 <limpo1989@gmail.com>. All rights reserved.

package protorpc

import (
	"bytes"
	"fmt"
	"os"
	"strings"
	"text/template"

	descriptor "github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
	generator "github.com/gogo/protobuf/protoc-gen-gogo/generator"
)

// option go_generic_services = ???;
const go_generic_services = "go_generic_services"

// pkg name as prefix of service name?
const go_generic_services_use_pkg_name = "go_generic_services_use_pkg_name"

// servicePlugin produce the Service interface.
type servicePlugin struct {
	*generator.Generator
}

// Name returns the name of the plugin.
func (p *servicePlugin) Name() string { return "protorpc" }

// Init is called once after data structures are built but before
// code generation begins.
func (p *servicePlugin) Init(g *generator.Generator) {
	p.Generator = g
}

// Generate produces the code generated by the plugin for this file.
func (p *servicePlugin) GenerateImports(file *generator.FileDescriptor) {
	if !p.getGenericServicesOptions(file) {
		return
	}
	if len(file.Service) > 0 {
		p.P(`import "time"`)
		//		p.P(`import "xnet"`)
	}
}

// Generate generates the Service interface.
// rpc service can't handle other proto message!!!
func (p *servicePlugin) Generate(file *generator.FileDescriptor) {
	if !p.getGenericServicesOptions(file) {
		return
	}
	for _, svc := range file.Service {
		p.genServiceInterface(file, svc)
		p.genServiceServer(file, svc)
		p.genServiceClient(file, svc)
		p.genServiceProxy(file, svc)
	}
}

func (p *servicePlugin) getGenericServicesOptions(file *generator.FileDescriptor) bool {

	env := go_generic_services

	// try command line first
	// protoc --go_out=go_generic_services=true:. xxx.proto
	if value, ok := p.Generator.Param[env]; ok {
		if value == "1" || strings.ToLower(value) == "true" {
			return true
		}
		if value == "0" || strings.ToLower(value) == "false" {
			return false
		}
	}

	// try environment second
	if value := os.Getenv(strings.ToUpper(env)); value != "" {
		if value == "1" || strings.ToLower(value) == "true" {
			return true
		}
		if value == "0" || strings.ToLower(value) == "false" {
			return false
		}
	}
	if value := os.Getenv(strings.ToLower(env)); value != "" {
		if value == "1" || strings.ToLower(value) == "true" {
			return true
		}
		if value == "0" || strings.ToLower(value) == "false" {
			return false
		}
	}

	// try proto file option last
	if file.GetOptions().GetCcGenericServices() {
		return true
	}
	return false
}

func (p *servicePlugin) getGenericServicesOptionsUsePkgName(
	file *generator.FileDescriptor,
) bool {
	env := go_generic_services_use_pkg_name

	// try command line first
	// protoc --go_out=go_generic_services_use_pkg_name=true:. xxx.proto
	if value, ok := p.Generator.Param[env]; ok {
		if value == "1" || strings.ToLower(value) == "true" {
			return true
		}
		if value == "0" || strings.ToLower(value) == "false" {
			return false
		}
	}

	if value := os.Getenv(strings.ToUpper(env)); value != "" {
		if value == "1" || strings.ToLower(value) == "true" {
			return true
		}
		if value == "0" || strings.ToLower(value) == "false" {
			return false
		}
	}
	if value := os.Getenv(strings.ToLower(env)); value != "" {
		if value == "1" || strings.ToLower(value) == "true" {
			return true
		}
		if value == "0" || strings.ToLower(value) == "false" {
			return false
		}
	}

	return false
}

func (p *servicePlugin) genServiceInterface(
	file *generator.FileDescriptor,
	svc *descriptor.ServiceDescriptorProto,
) {
	const serviceInterfaceTmpl = `
type I{{.ServiceName}} interface {
	{{.CallMethodList}}
}
`
	const callMethodTmpl = `
{{.MethodName}}(context *xnet.Context, in *{{.ArgsType}}, out *{{.ReplyType}}) *string`

	// gen call method list
	var callMethodList string
	for _, m := range svc.Method {
		out := bytes.NewBuffer([]byte{})
		t := template.Must(template.New("").Parse(callMethodTmpl))
		t.Execute(out, &struct{ ServiceName, MethodName, ArgsType, ReplyType string }{
			ServiceName: generator.CamelCase(svc.GetName()),
			MethodName:  generator.CamelCase(m.GetName()),
			ArgsType:    p.TypeName(p.ObjectNamed(m.GetInputType())),
			ReplyType:   p.TypeName(p.ObjectNamed(m.GetOutputType())),
		})
		callMethodList += out.String()

		p.RecordTypeUse(m.GetInputType())
		p.RecordTypeUse(m.GetOutputType())
	}

	// gen all interface code
	{
		out := bytes.NewBuffer([]byte{})
		t := template.Must(template.New("").Parse(serviceInterfaceTmpl))
		t.Execute(out, &struct{ ServiceName, CallMethodList string }{
			ServiceName:    generator.CamelCase(svc.GetName()),
			CallMethodList: callMethodList,
		})
		p.P(out.String())
	}
}

func (p *servicePlugin) genServiceServer(
	file *generator.FileDescriptor,
	svc *descriptor.ServiceDescriptorProto,
) {
	const serviceHelperFunTmpl = `
// generate {{.ServiceName}}Module to implementation IServiceModule.
type {{.ServiceName}}Module struct {
	I{{.ServiceName}}
}

func New{{.ServiceName}}Module(svc I{{.ServiceName}}) *{{.ServiceName}}Module {
	return &{{.ServiceName}}Module{ I{{.ServiceName}} : svc }
}

func(this *{{.ServiceName}}Module) Name() string {
	return "{{.ServiceName}}"
}

func(this *{{.ServiceName}}Module) Impl() interface{} {
	return this.I{{.ServiceName}}
}

func(this *{{.ServiceName}}Module) ServiceCall(ctx *xnet.Context, rpc_id uint32, in xnet.Message)(reply xnet.Message, err *string) {

	switch rpc_id {
	{{.CaseList}}
	default:
		err = proto.String("MethodNotFound")
	}

	return
}

// generate {{.ServiceName}}Impl
type {{.ServiceName}}Impl struct {
	*xnet.RpcService
	xnet.IServiceModule
}

// New{{.ServiceName}}Server returns a new {{.ServiceName}} Server.
func New{{.ServiceName}}Impl(rawurl string, impl I{{.ServiceName}}) (*{{.ServiceName}}Impl, error) {
	var service *xnet.RpcService
	var err error
	if service, err = xnet.ListenRpc( rawurl ); err != nil {
		return nil, err
	}
	return New{{.ServiceName}}ImplFrom( service, impl )
}

// New{{.ServiceName}}Server use proxy.
func New{{.ServiceName}}ImplWithProxy(rawurl, proxy_url string) (*{{.ServiceName}}Impl, error) {

	// dial remote service with proxy_url.
	impl, err := New{{.ServiceName}}Proxy(proxy_url, time.Second * 15)
	// dial remote service to failed.
	if err != nil {
		return nil, err
	}

	// create local service with rawurl.
	var service *{{.ServiceName}}Impl
	if service, err = New{{.ServiceName}}Impl(rawurl, impl); nil != err {
		impl.proxy.Close(err)
		return nil, err
	}

	return service, nil
}

func New{{.ServiceName}}ImplFrom( service *xnet.RpcService, impl I{{.ServiceName}} ) (*{{.ServiceName}}Impl, error) {
	svc_impl := &{{.ServiceName}}Impl {
		RpcService : service,
		IServiceModule: New{{.ServiceName}}Module(impl),
	}

	service.RegisterService( svc_impl.IServiceModule )

	return svc_impl, nil
}

func(this *{{.ServiceName}}Impl) Startup() {
	this.Dispatcher().RegisterService( this.IServiceModule )
}

func(this *{{.ServiceName}}Impl) Shutdown() {
	this.Dispatcher().UnregisterService( this.IServiceModule )
}
`
	const serviceHelperCaseTmpl = `case uint32({{.MethodHash}}):
out := &{{.ReplyType}}{}
reply, err = out, this.I{{.ServiceName}}.{{.MethodName}}( ctx, in.(*{{.ArgsType}}), out )
`

	{
		var CaseList string
		for _, m := range svc.Method {
			out := bytes.NewBuffer([]byte{})
			t := template.Must(template.New("").Parse(serviceHelperCaseTmpl))
			t.Execute(out, &struct {
				ServiceName, ServiceRegisterName, MethodName, ArgsType, ReplyType string
				MethodHash                                                        uint32
			}{
				ServiceName:         generator.CamelCase(svc.GetName()),
				ServiceRegisterName: generator.CamelCase(svc.GetName()),
				MethodName:          generator.CamelCase(m.GetName()),
				ArgsType:            p.TypeName(p.ObjectNamed(m.GetInputType())),
				ReplyType:           p.TypeName(p.ObjectNamed(m.GetOutputType())),
				MethodHash:          hash(fmt.Sprintf("%s.%s", generator.CamelCase(svc.GetName()), generator.CamelCase(m.GetName()))),
			})

			CaseList += out.String()
		}

		out := bytes.NewBuffer([]byte{})
		t := template.Must(template.New("").Parse(serviceHelperFunTmpl))
		t.Execute(out, &struct{ PackageName, ServiceName, ServiceRegisterName, CaseList string }{
			PackageName:         file.GetPackage(),
			ServiceName:         generator.CamelCase(svc.GetName()),
			ServiceRegisterName: "I" + generator.CamelCase(svc.GetName()),
			CaseList:            CaseList,
		})
		p.P(out.String())
	}
}

// 计算字符串hash, BKDRHash
func hash(str string) uint32 {

	// 31 131 1313 13131 131313 etc..
	seed, hash := uint32(131), uint32(0)

	for _, c := range []byte(str) {
		hash = hash*seed + uint32(c)
	}

	return (hash & 0x7FFFFFFF)
}

func (p *servicePlugin) genServiceClient(
	file *generator.FileDescriptor,
	svc *descriptor.ServiceDescriptorProto,
) {
	const clientHelperFuncTmpl = `
// define I{{.ServiceName}}Client interface
type I{{.ServiceName}}Client interface {
	xnet.ISession
	{{.DefMethodList}}	
}

// implement I{{.ServiceName}}Client interface.
type {{.ServiceName}}Client struct {
	xnet.ISession
}

// New {{.ServiceName}}Client from ISession.
func New{{.ServiceName}}Client( conn xnet.ISession ) I{{.ServiceName}}Client {
	return &{{.ServiceName}}Client{conn}
}

// Dial{{.ServiceName}} connects to an {{.ServiceName}} at the specified network address.
func Dial{{.ServiceName}}(rawurl string) (I{{.ServiceName}}Client, error) {
	return Dial{{.ServiceName}}Timeout(rawurl, time.Second * 15)
}

// Dial{{.ServiceName}} connects to an {{.ServiceName}} at the specified network address.
func Dial{{.ServiceName}}Timeout(rawurl string, timeout time.Duration) (I{{.ServiceName}}Client, error) {
	c, err := xnet.DialRpc(rawurl, timeout)
	if err != nil {
		return nil, err
	}
	return &{{.ServiceName}}Client{c}, nil
}


{{.MethodList}}
`
	const clientMethodTmpl = `
func (this *{{.ServiceName}}Client) {{.MethodName}}(in *{{.ArgsType}} ) (*{{.ReplyType}}, *string) {
	xnet.Assert( nil != in, "nil pointer: *{{.ArgsType}}" )
	// {{.ServiceRegisterName}}.{{.MethodName}} = {{.MethodHash}}
	// reply, err := this.Call( "{{.ServiceRegisterName}}.{{.MethodName}}", in )
	reply, err := this.CallTimeout( {{.MethodHash}}, xnet.RPC_TIMEOUT, in )
	if nil != reply && (*{{.ReplyType}})(nil) != reply {
		return reply.(*{{.ReplyType}}), err
	}
	return nil, err
}

func (this *{{.ServiceName}}Client) Async{{.MethodName}}(in *{{.ArgsType}}, handler func(*string, *{{.ReplyType}})) {
	xnet.Assert( nil != in, "nil pointer: *{{.ArgsType}}" )
	xnet.Assert( nil != handler, "nil handler: func(*string, *{{.ReplyType}})" )
	// {{.ServiceRegisterName}}.{{.MethodName}} = {{.MethodHash}}
	// this.AsyncCall("{{.ServiceRegisterName}}.{{.MethodName}}", in, func(err *string, reply xnet.Message) {
	this.AsyncCallTimeout( {{.MethodHash}}, xnet.RPC_TIMEOUT, in, func(err *string, reply xnet.Message) {
		var output *{{.ReplyType}}
		if nil != reply && (*{{.ReplyType}})(nil) != reply {
			output = reply.(*{{.ReplyType}})
		}
		handler( err, output )
	})
}
`

	const clientDefMethodTmpl = `
	{{.MethodName}}(*{{.ArgsType}}) (*{{.ReplyType}}, *string)
	Async{{.MethodName}}(*{{.ArgsType}}, func(*string, *{{.ReplyType}}))
`

	// gen client method list
	var methodList string
	var defMethodList string
	for _, m := range svc.Method {
		out := bytes.NewBuffer([]byte{})
		t := template.Must(template.New("").Parse(clientMethodTmpl))
		t.Execute(out, &struct {
			ServiceName, ServiceRegisterName, MethodName, ArgsType, ReplyType string
			MethodHash                                                        uint32
		}{
			ServiceName:         generator.CamelCase(svc.GetName()),
			ServiceRegisterName: generator.CamelCase(svc.GetName()),
			MethodName:          generator.CamelCase(m.GetName()),
			ArgsType:            p.TypeName(p.ObjectNamed(m.GetInputType())),
			ReplyType:           p.TypeName(p.ObjectNamed(m.GetOutputType())),
			MethodHash:          hash(fmt.Sprintf("%s.%s", generator.CamelCase(svc.GetName()), generator.CamelCase(m.GetName()))),
		})
		methodList += out.String()

		out = bytes.NewBuffer([]byte{})
		t = template.Must(template.New("").Parse(clientDefMethodTmpl))
		t.Execute(out, &struct {
			ServiceName, ServiceRegisterName, MethodName, ArgsType, ReplyType string
			MethodHash                                                        uint32
		}{
			ServiceName:         generator.CamelCase(svc.GetName()),
			ServiceRegisterName: generator.CamelCase(svc.GetName()),
			MethodName:          generator.CamelCase(m.GetName()),
			ArgsType:            p.TypeName(p.ObjectNamed(m.GetInputType())),
			ReplyType:           p.TypeName(p.ObjectNamed(m.GetOutputType())),
			MethodHash:          hash(fmt.Sprintf("%s.%s", generator.CamelCase(svc.GetName()), generator.CamelCase(m.GetName()))),
		})
		defMethodList += out.String()
	}

	// gen all client code
	{
		out := bytes.NewBuffer([]byte{})
		t := template.Must(template.New("").Parse(clientHelperFuncTmpl))
		t.Execute(out, &struct{ PackageName, ServiceName, MethodList, DefMethodList string }{
			PackageName:   file.GetPackage(),
			ServiceName:   generator.CamelCase(svc.GetName()),
			MethodList:    methodList,
			DefMethodList: defMethodList,
		})
		p.P(out.String())
	}
}

func (p *servicePlugin) genServiceProxy(
	file *generator.FileDescriptor,
	svc *descriptor.ServiceDescriptorProto,
) {

	const proxyHelperFuncTmpl = `
// generate {{.ServiceName}}Proxy to implementation I{{.ServiceName}} interface.
type {{.ServiceName}}Proxy struct {
	proxy I{{.ServiceName}}Client
}

func New{{.ServiceName}}Proxy(rawurl string, timeout time.Duration) (*{{.ServiceName}}Proxy, error) {
	client, err := Dial{{.ServiceName}}Timeout(rawurl, timeout)
	if nil != err {
		return nil, err
	}
	return &{{.ServiceName}}Proxy{ proxy: client }, nil
}

{{.MethodList}}
`

	const proxyMethodTmpl = `
// I{{.ServiceName}}.{{.MethodName}}
func (this *{{.ServiceName}}Proxy) {{.MethodName}}(ctx *xnet.Context, in *{{.ArgsType}}, out *{{.ReplyType}}) *string {
	this.proxy.Async{{.MethodName}}(in, func(err *string, resp *{{.ReplyType}}) {
		ctx.Response(err, resp)
	})
	return ctx.Asynchronized()
}
`

	// gen client method list
	var methodList string
	for _, m := range svc.Method {
		out := bytes.NewBuffer([]byte{})
		t := template.Must(template.New("").Parse(proxyMethodTmpl))
		t.Execute(out, &struct {
			ServiceName, ServiceRegisterName, MethodName, ArgsType, ReplyType string
			MethodHash                                                        uint32
		}{
			ServiceName:         generator.CamelCase(svc.GetName()),
			ServiceRegisterName: generator.CamelCase(svc.GetName()),
			MethodName:          generator.CamelCase(m.GetName()),
			ArgsType:            p.TypeName(p.ObjectNamed(m.GetInputType())),
			ReplyType:           p.TypeName(p.ObjectNamed(m.GetOutputType())),
			MethodHash:          hash(fmt.Sprintf("%s.%s", generator.CamelCase(svc.GetName()), generator.CamelCase(m.GetName()))),
		})
		methodList += out.String()
	}

	{
		out := bytes.NewBuffer([]byte{})
		t := template.Must(template.New("").Parse(proxyHelperFuncTmpl))
		t.Execute(out, &struct{ PackageName, ServiceName, MethodList string }{
			PackageName: file.GetPackage(),
			ServiceName: generator.CamelCase(svc.GetName()),
			MethodList:  methodList,
		})
		p.P(out.String())
	}
}

func (p *servicePlugin) makeServiceRegisterName(
	file *generator.FileDescriptor,
	packageName, serviceName string,
) string {
	if p.getGenericServicesOptionsUsePkgName(file) {
		return packageName + "." + serviceName
	}
	return serviceName
}

func init() {
	generator.RegisterPlugin(new(servicePlugin))
}
